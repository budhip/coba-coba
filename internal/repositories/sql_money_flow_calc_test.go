package repositories

import (
	"context"
	"database/sql"
	"errors"
	"regexp"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"go.uber.org/mock/gomock"

	"bitbucket.org/Amartha/go-fp-transaction/internal/common"
	"bitbucket.org/Amartha/go-fp-transaction/internal/common/accounting/mock"
	mockflag "bitbucket.org/Amartha/go-fp-transaction/internal/common/flag/mock"
	"bitbucket.org/Amartha/go-fp-transaction/internal/config"
	"bitbucket.org/Amartha/go-fp-transaction/internal/models"
)

func TestMoneyFlowRepositoryTestSuite(t *testing.T) {
	t.Helper()
	suite.Run(t, new(moneyFlowTestSuite))
}

type moneyFlowTestSuite struct {
	suite.Suite
	t             *testing.T
	writeDB       *sql.DB
	readDB        *sql.DB
	mockSql       sqlmock.Sqlmock
	mockFlag      *mockflag.MockClient
	moneyFlowRepo MoneyFlowRepository
}

func (suite *moneyFlowTestSuite) SetupTest() {
	var err error
	var cfg config.Config

	suite.writeDB, suite.mockSql, err = sqlmock.New()
	require.NoError(suite.T(), err)

	suite.readDB = suite.writeDB

	suite.t = suite.T()
	mockCtrl := gomock.NewController(suite.t)
	suite.mockFlag = mockflag.NewMockClient(mockCtrl)
	mockAccounting := mock.NewMockClient(mockCtrl)

	sqlRepository := NewSQLRepository(suite.writeDB, suite.readDB, cfg, suite.mockFlag, mockAccounting)
	suite.moneyFlowRepo = sqlRepository.GetMoneyFlowCalcRepository()
}

func (suite *moneyFlowTestSuite) TearDownTest() {
	defer suite.writeDB.Close()
	defer suite.readDB.Close()
}

func (suite *moneyFlowTestSuite) TestCreateSummary_Success() {
	input := models.CreateMoneyFlowSummary{
		TransactionSourceCreationDate: time.Now(),
		TransactionType:               "TYPE_A",
		PaymentType:                   "PAYMENT_A",
		ReferenceNumber:               "REF123",
		Description:                   "Test transaction",
		SourceAccount:                 "ACC001",
		DestinationAccount:            "ACC002",
		TotalTransfer:                 1000.00,
		PapaTransactionID:             "",
		MoneyFlowStatus:               "PENDING",
		RequestedDate:                 nil,
		ActualDate:                    nil,
		SourceBankAccountNumber:       "1234567890",
		SourceBankAccountName:         "Account Source",
		SourceBankName:                "Bank A",
		DestinationBankAccountNumber:  "0987654321",
		DestinationBankAccountName:    "Account Destination",
		DestinationBankName:           "Bank B",
	}

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryCreateSummary)).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).
			AddRow("summary-id-123"))

	result, err := suite.moneyFlowRepo.CreateSummary(context.Background(), input)

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "summary-id-123", result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestCreateSummary_DatabaseError() {
	input := models.CreateMoneyFlowSummary{
		TransactionSourceCreationDate: time.Now(),
		TransactionType:               "TYPE_A",
	}

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryCreateSummary)).
		WillReturnError(errors.New("database error"))

	result, err := suite.moneyFlowRepo.CreateSummary(context.Background(), input)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "", result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestCreateDetailedSummary_Success() {
	input := models.CreateDetailedMoneyFlowSummary{
		ID:                 "detail-id-123",
		SummaryID:          "summary-id-123",
		AcuanTransactionID: "acuan-trx-123",
	}

	// Use AnyString matcher for the auto-generated ID
	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(queryCreateDetailedSummary)).
		WithArgs(
			sqlmock.AnyArg(), // ID is auto-generated by uuid.New()
			"summary-id-123",
			"acuan-trx-123",
		).
		WillReturnResult(sqlmock.NewResult(1, 1))

	err := suite.moneyFlowRepo.CreateDetailedSummary(context.Background(), input)

	assert.NoError(suite.T(), err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestCreateDetailedSummary_NoRowsAffected() {
	input := models.CreateDetailedMoneyFlowSummary{
		ID:        "detail-id-123",
		SummaryID: "non-existent-summary",
	}

	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(queryCreateDetailedSummary)).
		WithArgs(
			sqlmock.AnyArg(), // ID is auto-generated
			"non-existent-summary",
			sqlmock.AnyArg(),
		).
		WillReturnResult(sqlmock.NewResult(0, 0))

	err := suite.moneyFlowRepo.CreateDetailedSummary(context.Background(), input)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), common.ErrNoRowsAffected, err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetTransactionProcessed_Success() {
	transactionSourceDate := time.Now()

	columns := []string{
		"id", "transaction_source_date", "transaction_type",
		"payment_type", "total_transfer", "money_flow_status",
	}

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetTransactionProcessed)).
		WithArgs("TYPE_A", transactionSourceDate).
		WillReturnRows(sqlmock.NewRows(columns).
			AddRow("trx-id-123", transactionSourceDate, "TYPE_A", "PAYMENT_A", decimal.NewFromFloat(1000.00), "PENDING"))

	result, err := suite.moneyFlowRepo.GetTransactionProcessed(context.Background(), "TYPE_A", transactionSourceDate)

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), result)
	assert.Equal(suite.T(), "trx-id-123", result.ID)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetTransactionProcessed_NotFound() {
	transactionSourceDate := time.Now()

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetTransactionProcessed)).
		WithArgs("TYPE_UNKNOWN", transactionSourceDate).
		WillReturnRows(sqlmock.NewRows([]string{
			"id", "transaction_source_date", "transaction_type",
			"payment_type", "total_transfer", "money_flow_status",
		}))

	result, err := suite.moneyFlowRepo.GetTransactionProcessed(context.Background(), "TYPE_UNKNOWN", transactionSourceDate)

	assert.NoError(suite.T(), err)
	assert.Nil(suite.T(), result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetTransactionProcessed_DatabaseError() {
	transactionSourceDate := time.Now()

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetTransactionProcessed)).
		WithArgs("TYPE_A", transactionSourceDate).
		WillReturnError(errors.New("database error"))

	result, err := suite.moneyFlowRepo.GetTransactionProcessed(context.Background(), "TYPE_A", transactionSourceDate)

	assert.Error(suite.T(), err)
	assert.Nil(suite.T(), result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestUpdateSummary_Success() {
	summaryID := "summary-id-123"
	newStatus := "SUCCESSFUL"
	newAmount := decimal.NewFromFloat(2000.00)

	update := models.MoneyFlowSummaryUpdate{
		MoneyFlowStatus: &newStatus,
		TotalTransfer:   &newAmount,
	}

	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(`UPDATE money_flow_summaries SET`)).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err := suite.moneyFlowRepo.UpdateSummary(context.Background(), summaryID, update)

	assert.NoError(suite.T(), err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestUpdateSummary_SingleField() {
	summaryID := "summary-id-123"
	newStatus := "SUCCESSFUL"

	update := models.MoneyFlowSummaryUpdate{
		MoneyFlowStatus: &newStatus,
	}

	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(`UPDATE money_flow_summaries SET`)).
		WillReturnResult(sqlmock.NewResult(0, 1))

	err := suite.moneyFlowRepo.UpdateSummary(context.Background(), summaryID, update)

	assert.NoError(suite.T(), err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestUpdateSummary_NoRowsAffected() {
	summaryID := "non-existent-summary"
	newStatus := "SUCCESSFUL"

	update := models.MoneyFlowSummaryUpdate{
		MoneyFlowStatus: &newStatus,
	}

	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(`UPDATE money_flow_summaries SET`)).
		WillReturnResult(sqlmock.NewResult(0, 0))

	err := suite.moneyFlowRepo.UpdateSummary(context.Background(), summaryID, update)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), common.ErrNoRowsAffected, err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestUpdateSummary_EmptyUpdate() {
	summaryID := "summary-id-123"
	update := models.MoneyFlowSummaryUpdate{}

	err := suite.moneyFlowRepo.UpdateSummary(context.Background(), summaryID, update)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "Error No Field to Update", err.Error())
}

func (suite *moneyFlowTestSuite) TestUpdateSummary_DatabaseError() {
	summaryID := "summary-id-123"
	newStatus := "SUCCESSFUL"

	update := models.MoneyFlowSummaryUpdate{
		MoneyFlowStatus: &newStatus,
	}

	suite.mockSql.
		ExpectExec(regexp.QuoteMeta(`UPDATE money_flow_summaries SET`)).
		WillReturnError(errors.New("database error"))

	err := suite.moneyFlowRepo.UpdateSummary(context.Background(), summaryID, update)

	assert.Error(suite.T(), err)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetSummaryIDByPapaTransactionID_Success() {
	papaTransactionID := "papa-trx-123"

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetSummaryIDByPapaTransactionID)).
		WithArgs(papaTransactionID).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).
			AddRow("summary-id-123"))

	result, err := suite.moneyFlowRepo.GetSummaryIDByPapaTransactionID(context.Background(), papaTransactionID)

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "summary-id-123", result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetSummaryIDByPapaTransactionID_NotFound() {
	papaTransactionID := "non-existent-papa-trx"

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetSummaryIDByPapaTransactionID)).
		WithArgs(papaTransactionID).
		WillReturnRows(sqlmock.NewRows([]string{"id"}))

	result, err := suite.moneyFlowRepo.GetSummaryIDByPapaTransactionID(context.Background(), papaTransactionID)

	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "", result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}

func (suite *moneyFlowTestSuite) TestGetSummaryIDByPapaTransactionID_DatabaseError() {
	papaTransactionID := "papa-trx-123"

	suite.mockSql.
		ExpectQuery(regexp.QuoteMeta(queryGetSummaryIDByPapaTransactionID)).
		WithArgs(papaTransactionID).
		WillReturnError(errors.New("database error"))

	result, err := suite.moneyFlowRepo.GetSummaryIDByPapaTransactionID(context.Background(), papaTransactionID)

	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "", result)

	if err := suite.mockSql.ExpectationsWereMet(); err != nil {
		suite.T().Errorf("there were unfulfilled expectations: %s", err)
	}
}
